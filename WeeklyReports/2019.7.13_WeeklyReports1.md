本周（2019.7.8-2019.7.13）主要对lab1和lab2前面一小部分的知识进行了学习，下面对学习的知识进行一下和存在的问题进行一些总结汇报：

### Lab1的知识汇报

1.PC机的物理地址中，最开始的第一代PC机只能访问0x00000000~0x000FFFFF处（1MB），其中最重要的BIOS就位于0x000F0000~0x00100000处。当现代的计算机的内存突破了1MB的内存空间，并且为了向后兼容，0x000A0000~0x00100000区间成为了一个空洞。

2.BIOS启动过程中，CPU采用的是实模式，地址计算为：段基址<<4+段内偏移，获得地址即为真实的物理地址。BIOS主要在控制、初始化、检测底层的设备，但是最重要的是最后加载Boot loader，BIOS把boot loader加载到0x7c00~0x7dff的地址区域，并将控制权交给boot loader。

3.boot loader程序中包括了boot.S和main.c文件，首先执行的是boot.S文件，**这个文件最重要的功能是将CPU转换为32位的保护模式**；而main.c最主要的功能是加载内核程序，首先是将内核文件的ELF头部读取到0x10000处，之后根据ELF头部信息和Program Header Table，再把内核加载到0x00100000处开始的地方。最后跳转到内核文件的执行入口，自此控制权就转交给了内核。

4.内核文件是一个ELF文件，文件格式为：ELF文件头，程序头表（program header table）、文件内容（包括.text节、.rodata节、.data节等）和节头表(section header table)。其中节内容希望被加载的逻辑地址（链接地址或者虚拟地址）和实际加载的地址（加载地址或物理地址）是不一样的，为此这涉及到了一个地址映射，在内核程序执行期间，这种映射由entry.S文件中手写的一个C语言页表实现。再实现了映射之后，接下去就是堆栈的初始化，堆栈中最重要的是esp、ebp寄存器，esp寄存器存放栈顶的内存地址，ebp和esp之间的内容为栈帧。最后是内核级别的输出，其中console.c文件主要是负责将字符输出显示到控制台，printfmt.c文件的内容主要是输出内容的格式转换，printf.c则是编程时最顶层的格式化输出函数的。

### 附Lab1的相关笔记和代码

1.[Lab1笔记地址](https://github.com/xiaoheidev/MIT6.828Learn/blob/master/notes/1PC Bootstrap.md)

2.[Lab1涉及到的实验代码](https://github.com/xiaoheidev/mit6.828)

### Lab2前一小部分的知识汇报

Lab2中主要讲的是内存的管理，在x86的保护模式下内存的管理架构是分段和分页，并同时引入了虚拟地址的概念。x86的虚拟地址中包括一个段选择子（segment selector）和一个段内偏移（segment offset ），虚拟地址通过段地址转化机制之后就成了**线性地址**（Linear Address），线性地址再经过分页地址转化机制就得到了物理地址（Physical Address）。在程序中，首先获取当前内存可以使用的大小，然后为页目录表开辟一段内存，之后通过page_init()函数初始化pages数组、pages_free_list链表等，再之后是对其进行检查。在这种机制下，物理页面分配粒度为4KB，对于物理内存的页面管理则是通过链表来实现，物理页对应的结构为`struct PageInfo`。



### 需要改进的地方

1.对堆栈这块有了一个初步的认识，明白了函数调用过程中，堆栈是怎么变化的，寄存器的值是怎么变化的。但是堆栈这块是很重要的知识点，需要更加深入了解一下，可以自己写一个函数去摸索一下堆栈这块更加详细的知识。

2.对x86寄存器的情况不太清楚，需要进一步了解，同时对x86指令结构也需要更加了解一下。

3.在内存管理这块，对地址有了一个清楚的认识，但是还需要通过代码加深对内存管理的掌握。